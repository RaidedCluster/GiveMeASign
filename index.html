<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ASL Fingerspelling</title>
    <style>
      @font-face {
        font-family: "Noto Sans SignWriting";
        src: url("NotoSansSignWriting-Regular.ttf") format("truetype");
        font-weight: normal;
        font-style: normal;
      }

      body {
        background-color: #0000cc;
        color: #ffff00;
        font-family: "Noto Sans", Arial, sans-serif; /* Changed for general text */
        padding: 2rem;
      }

      textarea {
        width: 100%;
        height: 100px;
        font-size: 1.2rem;
        padding: 0.5rem;
        margin-bottom: 1rem;
        background-color: transparent;
        color: #ffff00; /* Yellow text for textarea */
        border: 1px solid #ffff00; /* Yellow border for textarea */
      }

      button {
        margin-right: 1rem;
        padding: 0.5rem 1rem;
        font-size: 1rem;
        background-color: #ffff00;
        color: #0000cc;
        border: none;
        cursor: pointer;
      }

      pre {
        white-space: pre-wrap;
        font-size: 2rem;
        line-height: 2.5rem;
        margin-top: 1rem;
        word-wrap: break-word;
        font-family: "Noto Sans SignWriting", sans-serif; /* Explicitly for SignWriting output */
      }
    </style>
  </head>
  <body>
    <h1>ASL Fingerspelling</h1>
    <textarea id="inputText" placeholder="Type text here..."></textarea><br />
    <button onclick="render('horizontal')">Horizontal</button>
    <button onclick="render('vertical')">Vertical</button>
    <pre id="output"></pre>

    <script>
      const ASL_FINGERSPELL_DICT = {
        A: "ð£·ðªœ",
        B: "ð¡‡ðªœ",
        C: "ð¡­ðªœ",
        D: "ð ðªœ",
        E: "ð¡Šðªœ",
        F: "ð£Žðªœ",
        G: "ð£°",
        H: "ð •ðª¢",
        I: "ð¢’ðªœ",
        J: "ð¦¢ðª¬\nð¢’ðªœ",
        K: "ð¡€ðªœ",
        L: "ð£œðªœ",
        M: "ð¢ðªœ",
        N: "ð ™ðªœ",
        O: "ð¡¶ðªœ",
        P: "ð¡€ðªœðª¡",
        Q: "ð£±ðªœðª¡",
        R: "ð šðªœ",
        S: "ð¤ƒðªœ",
        T: "ð£»ðªœ",
        U: "ð •ðªœ",
        V: "ð Žðªœ",
        W: "ð¢‡ðªœ",
        X: "ð †ðªœ",
        Y: "ð¢šðªœ",
        Z: " ð¥…ðªª\nð €ðªœ",
        ".": "ðªˆðª¢",
        ",": "ðª‡ðª¢",
        ":": "ðªŠðª¢",
        ";": "ðª‰ðª¢",
        "(": "ðª‹ðª¢",
        ")": "ðª‹ðª¦",
        "?": "ð¦Ÿðªðª¬\nð €ðªœ",
        0: "ð¡¶ðªœ",
        1: "ð €ðªœ",
        2: "ð Žðªœ",
        3: "ð žðªœ",
        4: "ð¡„ðªœ",
        5: "ð¡Œðªœ",
        6: "ð¢‡ðªœ",
        7: "ð¢¥ðªœ",
        8: "ð¢»ðªœ",
        9: "ð£Žðªœ",
      };

      const VERTICAL_PUNCTUATION_OVERRIDES = {
        '.': 'ðªˆ',
        ',': 'ðª‡',
        ':': 'ðªŠ',
        ';': 'ðª‰',
        '(': 'ðª‹',
        ')': 'ðª‹ðª¤',
      };

      function textToFingerspell(text, mode) {
        if (!text || text.trim() === "") { // Handle empty or whitespace-only input
          return "";
        }
        if (mode === "vertical") {
          return text
            .split("")
            .map((c) => {
              if (VERTICAL_PUNCTUATION_OVERRIDES.hasOwnProperty(c)) {
                return VERTICAL_PUNCTUATION_OVERRIDES[c];
              }
              return ASL_FINGERSPELL_DICT[c.toUpperCase()] || c;
            })
            .join("\n");
        }

        // Horizontal mode
        const topLineSegments = [];
        const botLineSegments = [];
        let previousCharWasZ = false; // Flag to track if the *immediately preceding* character was Z

        for (const char of text) {
          const charUpper = char.toUpperCase();
          const sym = ASL_FINGERSPELL_DICT[charUpper] || char;
          const parts = sym.split("\n");

          let currentTopPart = "";
          let currentBotPart = "";

          if (parts.length === 1) { // Single-line symbol
            currentBotPart = parts[0];
            currentTopPart = "\u00A0"; // Always one non-breaking space
            previousCharWasZ = false; // Current char is not Z, so reset for next iteration
          } else { // Two-line symbol
            currentTopPart = parts[0]; // Raw top part
            currentBotPart = parts[1]; // Raw bottom part

            // Z-Z Ligature: If current is Z and previous was Z, remove leading space from current Z's top part
            if (charUpper === 'Z' && previousCharWasZ) {
              if (currentTopPart.startsWith(" ")) { // Check if it actually has a leading space
                currentTopPart = currentTopPart.substring(1);
              }
            }
            
            // Determine if the *current* character is Z for the *next* iteration's check
            if (charUpper === 'Z') {
              previousCharWasZ = true;
            } else {
              previousCharWasZ = false;
            }

            // Padding logic (if top is shorter than bottom)
            const topGlyphLength = Array.from(currentTopPart).length;
            const botGlyphLength = Array.from(currentBotPart).length;

            if (topGlyphLength < botGlyphLength) {
              currentTopPart += "\u00A0".repeat(botGlyphLength - topGlyphLength); // Use non-breaking spaces for padding
            }
          }
          topLineSegments.push(currentTopPart);
          botLineSegments.push(currentBotPart);
        }
        return topLineSegments.join("") + "\n" + botLineSegments.join("");
      }

      function render(mode) {
        const inputText = document.getElementById("inputText").value;
        const lines = inputText.split('\n'); // Split input by actual newline characters
        const outputSegments = [];

        for (const line of lines) {
          const fingerspelledLine = textToFingerspell(line, mode);
          // Only add non-empty results to our list of segments to be joined.
          if (fingerspelledLine !== "") {
            outputSegments.push(fingerspelledLine);
          }
        }
        // Join the processed, non-empty segments with two newlines as a separator.
        document.getElementById("output").textContent = outputSegments.join("\n\n");
      }
    </script>
  </body>
</html>
